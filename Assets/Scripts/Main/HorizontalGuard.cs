//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;

public class HorizontalGuard : MonoBehaviour{

public Transform leftBottom, leftEnd, rightBottom, rightEnd, sightStart, sightEnd; //2 transforms for start and end points for the linecast
//public GameObject arrow; //arrow above the guards head for alerted status
public Transform target;
public float smoothing = 1f;
private bool middleSplice, spottedLeft, spottedRight, spottedTop, wallCollide; //bool for if player is spotted, bool for if guard is facing up/down so we can rotate
private bool stuck = false;
private float counterStuck = 0;
public float speed = 1;
	public float chaseSpeed = 5;
private bool inConeFlag = false;
private bool isVolunteer;
private float counter = 0f;
	public AudioSource ActionBGM, CalmBGM, VisionField, Spotted;
	private bool notVolunteerBump;
	void Update(){

	Movement();
	RaycastStuff();
	Behaviour();
}

void Movement(){
	Physics2D.IgnoreLayerCollision(8,11);
	Physics2D.IgnoreLayerCollision(11,12);
	if (!inConeFlag && notVolunteerBump){
						transform.Translate (Vector3.up * 1f * Time.deltaTime * speed);
						stuck = false;
			//Debug.Log ("RIGHT HERE");
				} else {
					
			
			
						if (counterStuck <= 0.5f && stuck) {
								transform.Translate (Vector3.up * 1f  * Time.deltaTime * chaseSpeed);
								counterStuck += Time.deltaTime;
	
						} else {
								
								Vector3 targetSecurityPos = target.position;
								stuck = false;
								notVolunteerBump = true;
								/*float TX = target.position.x;
						float TY = target.position.y;
						float MX = transform.position.x;
						float MY = transform.position.y;

					else if (TX != MX || TY != MY) {
						ang = (Mathf.Tan ((TX - MX) / (TY - MY)) * Mathf.Rad2Deg);
								if (TX < MX && TY > MY) {
										ang = -ang;
								}
								else if (TX > MX && TY > MY) {
										ang = -ang;
								}
								else if (TX > MX && TY < MY) {
										ang = 180.0f - ang;
								}
								else if (TX < MX && TY < MY) {
										ang = 180.0f - ang;
								}

								
								if (notFirst) {
										if(ang<0){
											ang += 360.0f;
										}
																
										transform.rotation = Quaternion.AngleAxis (ang, Vector3.forward);
	
								} else {

										notFirst = true;
								}
								//transform.LookAt (target.position, Vector3.up);

								
					}*/
					
								Vector3 vectorToTarget = target.position - transform.position;
								float angle = - ((Mathf.Atan2 (vectorToTarget.y, vectorToTarget.x) * Mathf.Rad2Deg) - 90);
								Quaternion q = Quaternion.AngleAxis (angle, Vector3.back);
								transform.rotation = Quaternion.Slerp (transform.rotation, q, Time.deltaTime * 5);

								transform.position = Vector3.Lerp (transform.position, targetSecurityPos, 0.003f * chaseSpeed);
				if (inConeFlag == true &&(ActionBGM.audio.isPlaying == false)) {		
					CalmBGM.audio.Pause ();
					ActionBGM.audio.Play ();
					VisionField.audio.Play ();
					Spotted.audio.Play ();
				}
			}
				}
}

void RaycastStuff() //Keep our raycast code tidy in here
{
		Debug.DrawLine(sightStart.position, sightEnd.position, Color.magenta); //just a visual representation for the linecast
		spottedLeft = Physics2D.Linecast(leftBottom.position, leftEnd.position, 1 << LayerMask.NameToLayer("Player")); //we assign the bool 'spotted' with a linecast, that returns true or false when it touches the Player
		spottedRight = Physics2D.Linecast(rightBottom.position, rightEnd.position, 1 << LayerMask.NameToLayer("Player")); //we assign the bool 'spotted' with a linecast, that returns true or false when it touches the Player
		spottedTop = Physics2D.Linecast (leftEnd.position, rightEnd.position, 1 << LayerMask.NameToLayer ("Player"));
		wallCollide = Physics2D.Linecast(sightStart.position, sightEnd.position, 1 << LayerMask.NameToLayer("StaticObject"));
		middleSplice = Physics2D.Linecast(sightStart.position, sightEnd.position, 1 << LayerMask.NameToLayer("Player"));
		isVolunteer = Physics2D.Linecast (sightStart.position, sightEnd.position, 1 << LayerMask.NameToLayer ("Volunteer"));
	}

void Behaviour(){
				if (wallCollide == true || isVolunteer) {
					counter += Time.deltaTime;
		 		}
				if (spottedTop || spottedLeft || spottedRight || middleSplice || inConeFlag) {
						
						chaseSpeed += Time.deltaTime * speed/4;
						inConeFlag = true;
						if (speed > 45)
							speed = 45f;
						
						// ADD DESIRED BEHAVIOUR POTENTIALLY FOLLOWING?
				} 

				if (counter > 0.5f && !stuck) {

						stuck = true;
						int i = Random.Range (1, 5);
						switch (i) {
						case 1:
								transform.eulerAngles = new Vector3 (0, 0, 90);
								break;
						case 2:
								transform.eulerAngles = new Vector3 (0, 0, 180);
								break;
						case 3:
								transform.eulerAngles = new Vector3 (0, 0, 270);
								break;
						case 4:
								transform.eulerAngles = new Vector3 (0,0,0);
								break;
						}
			   		counter = 0;
					notVolunteerBump = false;
				
				}
			/*else {
						inConeFlag = false;
						speed = 1;
				}
				*/
		}

	}